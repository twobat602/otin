local player = game.Players.LocalPlayer
local mouse = player:GetMouse()
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

-- Load RedzLib UI Library
local redzlib = loadstring(game:HttpGet("https://raw.githubusercontent.com/tbao143/Library-ui/refs/heads/main/Redzhubui"))()
local Window = redzlib:MakeWindow({
    Title = "redz Hub : The Sewers",
    SubTitle = "by Twobat",
    SaveFolder = "testando | redz lib v5.lua"
})

Window:AddMinimizeButton({
    Button = { Image = "rbxassetid://119965632862212", BackgroundTransparency = 0 },
    Corner = { CornerRadius = UDim.new(35, 1) },
})

-- --- PLAYER TAB ---
local TabPlayer = Window:MakeTab({"Player", "person"})
Window:SelectTab(TabPlayer) -- Selects this tab initially

TabPlayer:AddParagraph({"⚠ Take Note!", "This script is still in beta, so you might encounter some bugs."})

-- Player List Dropdown and Teleport Logic
local selectedPlayerName = nil -- Renamed to avoid confusion with selectedPartRef
local playerDropdown -- Declare dropdown variable outside for scope

local function getPlayerNames()
    local names = {}
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= player then -- Exclude self
            table.insert(names, plr.Name)
        end
    end
    return names
end

playerDropdown = TabPlayer:AddDropdown({
    Name = "Players List",
    Description = "Select a player to teleport to",
    Options = getPlayerNames(), -- Initial list
    Default = "",
    Flag = "PlayerDropdown",
    Callback = function(Value)
        selectedPlayerName = Value
    end
})

local function updatePlayerList()
    local updatedNames = getPlayerNames()
    playerDropdown:Refresh(updatedNames)
    -- Reset selected player if they left
    if selectedPlayerName and not Players:FindFirstChild(selectedPlayerName) then
        selectedPlayerName = nil
        playerDropdown:SetValue("") -- Clear dropdown visually
    end
end

-- Auto-refresh when player joins or leaves
Players.PlayerAdded:Connect(updatePlayerList)
Players.PlayerRemoving:Connect(updatePlayerList)

-- Refresh Button
TabPlayer:AddButton({
    Name = "Refresh Player List",
    Callback = function()
        updatePlayerList()
    end
})

-- Teleport Button (You go to the selected player)
TabPlayer:AddButton({
    Name = "Teleport to Player",
    Callback = function()
        if selectedPlayerName then
            local targetPlayer = Players:FindFirstChild(selectedPlayerName)
            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                -- Check if your character exists before teleporting
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    player.Character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame
                else
                    warn("Your character is not ready for teleportation.")
                end
            else
                warn("Target player or their character/root part not found.")
            end
        else
            warn("No player selected for teleport.")
        end
    end
})

TabPlayer:AddParagraph({"How to use bring player", "Click the 'Get BeanBag' button first to teleport your beanbag to you.\nThen ask another player to join your clan/sit on it. Go to the desired location, then click 'Bring Player' again to teleport the beanbag (with the player) to you."})

-- Get BeanBag Button (Renamed for clarity based on description)
TabPlayer:AddButton({"Get BeanBag", function()
    -- Assuming "BeanBag" is your own owned beanbag
    local dynamicFurniture = Workspace:WaitForChild("DynamicFurniture", 9e9)
    local beanBag = nil
    for _, obj in ipairs(dynamicFurniture:GetChildren()) do
        if obj:IsA("Model") and obj.Name == "BeanBag" then
            -- Find the beanbag owned by the current player
            if obj:GetAttribute("Owner") == player.UserId then
                beanBag = obj
                break
            end
        end
    end

    if beanBag then
        -- You cannot directly set the CFrame of server-owned models/parts
        -- This operation would require a RemoteEvent to the server
        -- If this is for a local-only / client-sided script context where you have network ownership, it might work.
        -- Otherwise, you need a RemoteEvent.
        local playerRoot = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if playerRoot then
            -- If BeanBag has a PrimaryPart, use SetPrimaryPartCFrame
            if beanBag.PrimaryPart then
                beanBag:SetPrimaryPartCFrame(playerRoot.CFrame * CFrame.new(0, 0, -5))
            else
                -- Fallback if no PrimaryPart, assuming a main meshpart
                local meshPart = beanBag:FindFirstChildOfClass("MeshPart")
                if meshPart then
                    meshPart.CFrame = playerRoot.CFrame * CFrame.new(0, 0, -5)
                else
                    warn("BeanBag model has no PrimaryPart or MeshPart to move.")
                end
            end
            print("Your BeanBag moved to your front.")
        else
            warn("Your character is not ready to move the BeanBag.")
        end
    else
        warn("No BeanBag owned by you found in DynamicFurniture.")
    end
end})

-- --- COLLECT TAB ---
local TabCollect = Window:MakeTab({"Collect", "cherry"})

TabCollect:AddParagraph({"Farm gear/bottle", "This is not automatically placed, you need an Extractor for farming gear and bottle"})

-- Helper function for collecting items
local function collectItem(itemName)
    for _, item in ipairs(Workspace.DynamicFurniture:GetChildren()) do
        if item:IsA("Model") and item.Name == itemName then
            local ownerAttribute = item:GetAttribute("Owner")

            if ownerAttribute == nil then -- Only teleport if unowned
                local playerRoot = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                if playerRoot then
                    -- Prefer SetPrimaryPartCFrame for models, ensure PrimaryPart is set in Studio
                    if item.PrimaryPart then
                        item:SetPrimaryPartCFrame(playerRoot.CFrame * CFrame.new(0, 0, -2))
                    else
                        local smoothPart = item:FindFirstChildWhichIsA("BasePart") -- Generalize to BasePart
                        if smoothPart then
                            smoothPart.CFrame = playerRoot.CFrame * CFrame.new(0, 0, -2)
                        else
                            warn("Item '" .. itemName .. "' has no PrimaryPart or BasePart to move.")
                        end
                    end
                else
                    warn("Your character is not ready to collect " .. itemName .. ".")
                end
            end
        end
    end
    print("Attempted to collect all unowned " .. itemName .. "s.")
end

TabCollect:AddButton({"Collect All Scrap2", function() collectItem("Scrap2") end})
TabCollect:AddButton({"Collect All Pallet2", function() collectItem("Pallet2") end})
TabCollect:AddButton({"Collect All Television", function() collectItem("Television") end})
TabCollect:AddButton({"Collect All TrashCan", function() collectItem("TrashCan") end})

---
--- AUTO COLLECT SECTION
---
local Section = TabCollect:AddSection({"Auto Collect"})
local function fireProximityPrompt(prompt, holdFactor)
    -- Standard Roblox ProximityPrompt interaction from client
    if prompt.Triggered then -- Check if it's a server-sided prompt that can be triggered (unlikely for client)
        -- This part will likely NOT work for server-owned prompts from a LocalScript.
        -- It's included if 'fireproximityprompt' is a global function from an exploit.
        -- If it's a standard prompt, client cannot fire Triggered directly.
        -- This line should be replaced with RemoteEvent if server interaction is needed.
        if prompt.ClickablePrompt then
            -- Assuming this is a custom flag for an exploit-specific function
            -- If it's a standard prompt, these args are ignored or error.
            pcall(function() fireproximityprompt(prompt, holdFactor) end)
        else
            pcall(function() fireproximityprompt(prompt) end)
        end
    else -- Standard Roblox API for client interaction
        prompt:InputHoldBegin()
        task.wait(prompt.HoldDuration) -- Simulate holding it down
        prompt:InputHoldEnd()
    end
end

-- Collect Snow Toggle
local teleportingSnow = false -- Renamed to avoid conflict with `teleporting` in "Safety First"

TabCollect:AddToggle({
    Name = "Collect Snow",
    Default = false,
    Callback = function(v)
        teleportingSnow = v

        if teleportingSnow then
            task.spawn(function()
                local char = player.Character or player.CharacterAdded:Wait()
                local hum = char:FindFirstChildOfClass("Humanoid")
                local rootPart = char:FindFirstChild("HumanoidRootPart")
                local camera = Workspace.CurrentCamera

                if not hum or not rootPart or not camera then
                    warn("Character components not found for Collect Snow.")
                    teleportingSnow = false
                    return
                end

                local originalWalkSpeed = hum.WalkSpeed
                hum.WalkSpeed = 0 -- Stop player movement

                -- Loop while toggle is on
                while teleportingSnow do
                    local collectedAny = false
                    for _, snow in ipairs(Workspace.DynamicFurniture:GetChildren()) do
                        if not teleportingSnow then break end -- Break if toggle turned off mid-loop

                        if snow:IsA("Model") and snow.Name == "Snow" then
                            local meshPart = snow:FindFirstChildWhichIsA("BasePart") -- Generalize to BasePart
                            local prompt = snow:FindFirstChildWhichIsA("ProximityPrompt")

                            if meshPart and prompt then
                                rootPart.CFrame = meshPart.CFrame -- Teleport to snow
                                task.wait(0.2)
                                -- Optional: Adjust camera for better view or prompt visibility
                                camera.CFrame = CFrame.new(camera.CFrame.Position, rootPart.Position - Vector3.new(0, 15, 0))
                                task.wait(0.5)

                                fireProximityPrompt(prompt) -- Use the helper function
                                collectedAny = true
                                task.wait(2) -- Wait after interacting with one snow
                            end
                        end
                    end
                    if not collectedAny and teleportingSnow then
                        -- If no snow was found but toggle is still on, wait and try again
                        task.wait(5) -- Wait longer if no items found to avoid busy-waiting
                    elseif collectedAny then
                        task.wait(1) -- Short wait before checking for more items
                    end
                end

                hum.WalkSpeed = originalWalkSpeed -- Restore walkspeed when done
                print("Collect Snow stopped.")
            end)
        else
            -- When toggle is turned OFF
            local char = player.Character
            if char then
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    hum.WalkSpeed = 16 -- Ensure walkspeed is restored
                end
            end
            print("Collect Snow toggle OFF.")
        end
    end
})

-- Collect Burger Toggle
local collectingBurger = false
local noclipConnectionBurger -- Renamed for clarity to avoid general 'noclipConnection'

TabCollect:AddToggle({
    Name = "Collect Burger",
    Default = false,
    Callback = function(v)
        collectingBurger = v

        if collectingBurger then
            task.spawn(function()
                local char = player.Character or player.CharacterAdded:Wait()
                local hum = char:FindFirstChildOfClass("Humanoid")
                local rootPart = char:FindFirstChild("HumanoidRootPart")
                local camera = Workspace.CurrentCamera

                if not hum or not rootPart or not camera then
                    warn("Character components not found for Collect Burger.")
                    collectingBurger = false
                    return
                end

                local originalWalkSpeed = hum.WalkSpeed
                hum.WalkSpeed = 0 -- Stop player movement

                -- Noclip (Client-sided: May cause desync/rubberbanding for non-exploit contexts)
                noclipConnectionBurger = RunService.Stepped:Connect(function()
                    for _, part in pairs(char:GetDescendants()) do
                        if part:IsA("BasePart") and part.CanCollide then
                            part.CanCollide = false
                        end
                    end
                end)

                while collectingBurger do
                    local collectedAny = false
                    for _, burger in ipairs(Workspace.DynamicFurniture:GetChildren()) do
                        if not collectingBurger then break end

                        if burger:IsA("Model") and burger.Name == "Burger" then
                            local meshPart = burger:FindFirstChildWhichIsA("BasePart") -- Generalize to BasePart
                            local prompt = burger:FindFirstChildWhichIsA("ProximityPrompt")

                            if meshPart and prompt then
                                rootPart.CFrame = CFrame.new(meshPart.Position + Vector3.new(0, 6, 0))
                                task.wait(0.2)
                                camera.CFrame = CFrame.new(camera.CFrame.Position, rootPart.Position - Vector3.new(0, 15, 0))
                                task.wait(0.5)

                                fireProximityPrompt(prompt)
                                collectedAny = true
                                task.wait(2)
                            end
                        end
                    end
                    if not collectedAny and collectingBurger then
                        task.wait(5)
                    elseif collectedAny then
                        task.wait(1)
                    end
                end

                -- Cleanup when loop finishes or toggle is turned off
                if noclipConnectionBurger then
                    noclipConnectionBurger:Disconnect()
                    noclipConnectionBurger = nil
                end
                hum.WalkSpeed = originalWalkSpeed -- Restore walkspeed
                print("Collect Burger stopped.")
            end)
        else
            -- When toggle is turned OFF
            if noclipConnectionBurger then
                noclipConnectionBurger:Disconnect()
                noclipConnectionBurger = nil
            end
            local char = player.Character
            if char then
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    hum.WalkSpeed = 16 -- Ensure walkspeed is restored
                    for _, part in pairs(char:GetDescendants()) do
                        if part:IsA("BasePart") and not part.CanCollide then -- Only re-enable if it was disabled
                            part.CanCollide = true
                        end
                    end
                end
            end
            print("Collect Burger toggle OFF.")
        end
    end
})

-- Collect Cheese Toggle
local collectingCheese = false
TabCollect:AddToggle({
    Name = "Collect Cheese",
    Default = false,
    Callback = function(v)
        collectingCheese = v

        if collectingCheese then
            task.spawn(function()
                local char = player.Character or player.CharacterAdded:Wait()
                local hum = char:FindFirstChildOfClass("Humanoid")
                local rootPart = char:FindFirstChild("HumanoidRootPart")
                local camera = Workspace.CurrentCamera

                if not hum or not rootPart or not camera then
                    warn("Character components not found for Collect Cheese.")
                    collectingCheese = false
                    return
                end

                local originalWalkSpeed = hum.WalkSpeed
                hum.WalkSpeed = 0

                while collectingCheese do
                    local collectedAny = false
                    for _, cheese in ipairs(Workspace.DynamicFurniture:GetChildren()) do
                        if not collectingCheese then break end

                        if cheese:IsA("Model") and cheese.Name == "Cheese" then
                            local prompt = cheese:FindFirstChildWhichIsA("ProximityPrompt")
                            -- Prefer PrimaryPart for Models, if set
                            local targetPart = cheese.PrimaryPart or cheese:FindFirstChildWhichIsA("BasePart")

                            if targetPart and prompt then
                                rootPart.CFrame = CFrame.new(targetPart.Position + Vector3.new(0, 3, 0))
                                task.wait(0.1)
                                camera.CFrame = CFrame.new(camera.CFrame.Position, rootPart.Position - Vector3.new(0, 15, 0))

                                fireProximityPrompt(prompt)
                                collectedAny = true
                                task.wait(1.2)
                            end
                        end
                    end
                    if not collectedAny and collectingCheese then
                        task.wait(5)
                    elseif collectedAny then
                        task.wait(0.3)
                    end
                end

                hum.WalkSpeed = originalWalkSpeed
                print("Collect Cheese stopped.")
            end)
        else
            local char = player.Character
            if char then
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    hum.WalkSpeed = 16
                end
            end
            print("Collect Cheese toggle OFF.")
        end
    end
})

-- Collect Mushroom Toggle
local collectingMushroom = false
TabCollect:AddToggle({
    Name = "Collect Mushroom",
    Default = false,
    Callback = function(v)
        collectingMushroom = v

        if collectingMushroom then
            task.spawn(function()
                local char = player.Character or player.CharacterAdded:Wait()
                local hum = char:FindFirstChildOfClass("Humanoid")
                local rootPart = char:FindFirstChild("HumanoidRootPart")
                local camera = Workspace.CurrentCamera

                if not hum or not rootPart or not camera then
                    warn("Character components not found for Collect Mushroom.")
                    collectingMushroom = false
                    return
                end

                local originalWalkSpeed = hum.WalkSpeed
                hum.WalkSpeed = 0

                while collectingMushroom do
                    local collectedAny = false
                    for _, mushroom in ipairs(Workspace.DynamicFurniture:GetChildren()) do
                        if not collectingMushroom then break end

                        if mushroom:IsA("Model") and mushroom.Name == "MushroomBase" then
                            local prompt = mushroom:FindFirstChildWhichIsA("ProximityPrompt")
                            -- Prefer PrimaryPart for Models, if set
                            local targetPart = mushroom.PrimaryPart or mushroom:FindFirstChildWhichIsA("BasePart")

                            if targetPart and prompt then
                                rootPart.CFrame = CFrame.new(targetPart.Position + Vector3.new(0, 3, 0))
                                task.wait(0.3)
                                camera.CFrame = CFrame.new(camera.CFrame.Position, rootPart.Position - Vector3.new(0, 15, 0))

                                fireProximityPrompt(prompt)
                                collectedAny = true
                                task.wait(1.5)
                            end
                        end
                    end
                    if not collectedAny and collectingMushroom then
                        task.wait(5)
                    elseif collectedAny then
                        task.wait(0.5)
                    end
                end

                hum.WalkSpeed = originalWalkSpeed
                print("Collect Mushroom stopped.")
            end)
        else
            local char = player.Character
            if char then
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    hum.WalkSpeed = 16
                end
            end
            print("Collect Mushroom toggle OFF.")
        end
    end
})

---
--- ESP ITEMS SECTION
---
local Section = TabCollect:AddSection({"ESP Item"})
TabCollect:AddParagraph({"!", "Don't enable them all at the same time to avoid issues. This is still in beta, so expect some bugs."})

local ESP_Enabled = {}
local Beams = {}
local ESP_Highlights = {} -- Store highlights for proper cleanup if Adornee is part of model

local Colors = {
    Burger = Color3.fromRGB(255, 0, 0),       -- Red
    Cheese = Color3.fromRGB(255, 255, 0),     -- Yellow
    MushroomBase = Color3.fromRGB(0, 255, 0)  -- Green
}

function CreateESP(item, name)
    -- Ensure PrimaryPart exists, or find a suitable BasePart if it's a model
    local adorneePart = item
    if item:IsA("Model") then
        adorneePart = item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart")
    end
    if not adorneePart then return end -- Skip if no valid part found

    -- Create Highlight
    local highlightName = "ESP_" .. name
    local highlight = adorneePart:FindFirstChild(highlightName)
    if not highlight or not highlight:IsA("Highlight") then
        highlight = Instance.new("Highlight")
        highlight.Parent = adorneePart
        highlight.Adornee = adorneePart -- Highlight directly on the part
        highlight.FillColor = Colors[name]
        highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
        highlight.FillTransparency = 0.2
        highlight.OutlineTransparency = 0
        highlight.Name = highlightName
        ESP_Highlights[adorneePart] = highlight -- Store reference for cleanup
    end

    -- Create Beam
    if not Beams[item] then
        local startAttachment = Instance.new("Attachment")
        startAttachment.Name = "ESP_Start_" .. name
        local endAttachment = Instance.new("Attachment")
        endAttachment.Name = "ESP_End_" .. name
        local beam = Instance.new("Beam")
        beam.Name = "ESP_Beam_" .. name

        -- Ensure HumanoidRootPart exists for the start attachment
        local rootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not rootPart then
            -- Connect CharacterAdded to try again if character isn't ready
            LocalPlayer.CharacterAdded:Once(function(char)
                rootPart = char:WaitForChild("HumanoidRootPart")
                startAttachment.Parent = rootPart
            end)
        else
            startAttachment.Parent = rootPart
        end
        endAttachment.Parent = adorneePart -- Attach to the item's main part

        beam.Attachment0 = startAttachment
        beam.Attachment1 = endAttachment
        beam.Color = ColorSequence.new(Colors[name])
        beam.Width0 = 0.2
        beam.Width1 = 0.2
        beam.Parent = startAttachment -- Parent beam to attachment for easy cleanup

        Beams[item] = {beam, startAttachment, endAttachment}
    end
end

function RemoveESP(item)
    local highlightName = "ESP_" .. item.Name
    local adorneePart = item
    if item:IsA("Model") then
        adorneePart = item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart")
    end

    if adorneePart then
        local highlight = adorneePart:FindFirstChild(highlightName)
        if highlight and highlight:IsA("Highlight") then
            highlight:Destroy()
        end
        ESP_Highlights[adorneePart] = nil
    end

    if Beams[item] then
        for _, obj in ipairs(Beams[item]) do
            if obj and obj.Parent then -- Check if object still exists and has a parent
                obj:Destroy()
            end
        end
        Beams[item] = nil
    end
end

-- Update all active ESPs and clean up inactive ones
local espConnection -- To manage the Heartbeat connection
function UpdateESP()
    for _, item in pairs(Workspace.DynamicFurniture:GetChildren()) do
        if item:IsA("Model") and Colors[item.Name] then
            if ESP_Enabled[item.Name] then
                CreateESP(item, item.Name)
            else
                RemoveESP(item)
            end
        end
    end
end

function ToggleESP(name, enabled)
    ESP_Enabled[name] = enabled
    UpdateESP() -- Update immediately when toggle changes

    -- Manage the Heartbeat connection
    if table.unpack(ESP_Enabled) then -- If any ESP is enabled
        if not espConnection then
            espConnection = RunService.Heartbeat:Connect(UpdateESP) -- Start a continuous update
        end
    else -- If all ESPs are disabled
        if espConnection then
            espConnection:Disconnect()
            espConnection = nil
        end
    end
end

TabCollect:AddToggle({
    Name = "Burger ESP",
    Default = false,
    Callback = function(v)
        ToggleESP("Burger", v)
    end
})

TabCollect:AddToggle({
    Name = "Cheese ESP",
    Default = false,
    Callback = function(v)
        ToggleESP("Cheese", v)
    end
})

TabCollect:AddToggle({
    Name = "MushroomBase ESP",
    Default = false,
    Callback = function(v)
        ToggleESP("MushroomBase", v)
    end
})

-- --- INVENTORY TAB ---
-- Removed duplicate declaration of TabInv. Assuming the UI Library's AddTab is only called once.
local TabInv = Window:MakeTab({"Inventory", "save"}) -- This should be the FIRST and ONLY declaration
TabInv:AddParagraph({"For Safety", "This Feature can prevent you from losing valuable items if you're about to die."})
TabInv:AddParagraph({"Take note", "You will need a chest for this feature. Don't forget it!"})

-- Variables for selection state (already defined globally at the top)
-- local selectedPartIndex = nil
-- local selectedPartRef = nil
-- local readyToSelect = false
-- local moving = false

-- --- Helper function for highlighting (already defined globally above) ---
-- These functions are shared between the UI and ESP, keeping them up top global.
-- `applyHighlight` and `removeHighlight`

-- --- BUTTON: Enable click-to-select mode ---
TabInv:AddButton({"Click Chest", function() -- No Value parameter needed for a button that just sets a flag
    readyToSelect = true
    print("Click Chest mode enabled. Click on a Chest in DynamicFurniture.")
    if selectedPartRef then
        removeHighlight(selectedPartRef)
        selectedPartRef = nil
        selectedPartIndex = nil
        player:SetAttribute("SelectedPartIndex", nil)
    end
end})

-- --- ONE-TIME CLICK SELECT (if ready) --- (already defined globally above)
-- mouse.Button1Down:Connect(function() ... end)

-- --- TOGGLE: Auto move when HP ≤ 80% --- (already defined globally above)
-- local Toggle1 = TabInv:AddToggle({ ... })

-- --- RESTORE HIGHLIGHT ON RESPAWN --- (already defined globally above)
-- player.CharacterAdded:Connect(function() ... end)

---
--- NEW BUTTON: Move Manually
---
TabInv:AddButton({"Move Manually", function()
    if selectedPartRef then
        print("Manually moving items to selected Chest.")
        for i = 0, 27 do
            local args = {
                [1] = i;
                [2] = selectedPartRef; -- Use the directly selected Part/Model
            }
            ReplicatedStorage:WaitForChild("shared/network@GlobalEvents", 9e9):WaitForChild("moveItemToChest", 9e9):FireServer(unpack(args))
        end
        print("Manual move completed.")
    else
        warn("No Chest selected. Please use 'Click Chest' button to select one first.")
    end -- Fixed missing `end` bracket
})

---
--- NEW BUTTON: Open Chest (Fire ProximityPrompt)
---
TabInv:AddButton({"Open Chest", function()
    if selectedPartRef then
        local proximityPrompt = nil

        -- Search for ProximityPrompt within the selectedPartRef or its descendants
        -- Use FindFirstChildOfClass for better type safety
        if selectedPartRef:IsA("ProximityPrompt") then -- If the selected object IS the prompt itself
            proximityPrompt = selectedPartRef
        else -- Search within the selected model/part
            proximityPrompt = selectedPartRef:FindFirstChildOfClass("ProximityPrompt")
            if not proximityPrompt then
                for _, descendant in ipairs(selectedPartRef:GetDescendants()) do
                    if descendant:IsA("ProximityPrompt") then
                        proximityPrompt = descendant
                        break
                    end
                end
            end
        end

        if proximityPrompt then
            -- Simulate the prompt being triggered using standard API
            fireProximityPrompt(proximityPrompt) -- Use the helper function
            print("Fired ProximityPrompt for selected Chest.")
        else
            warn("No ProximityPrompt found in the selected Chest. Make sure the Chest model has a ProximityPrompt.")
        end
    else
        warn("No Chest selected. Please use 'Click Chest' button to select one first.")
    end
})


-- --- SHOP TAB ---
local TabShop = Window:MakeTab({"Shop", "shopping-cart"})
TabShop:AddParagraph({"Paragraph", "Premium Shop\nuhmm"})

TabShop:AddButton({"Buy Railgun (5364 bottle needs)", function() -- Removed Value parameter as it's not used
    local args = {
        [1] = "Railgun";
    }
    ReplicatedStorage:WaitForChild("shared/network@GlobalEvents", 9e9):WaitForChild("buyItem", 9e9):FireServer(unpack(args))
end})

TabShop:AddButton({"Buy AssaultRifle (16091 bottle needs)", function() -- Removed Value parameter as it's not used
    local args = {
        [1] = "AssaultRifle";
    }
    ReplicatedStorage:WaitForChild("shared/network@GlobalEvents", 9e9):WaitForChild("buyItem", 9e9):FireServer(unpack(args))
end})

-- --- SETTING TAB ---
local TabSetting = Window:MakeTab({"Setting", "apple"})

-- Variables for saved position (global scope for this section)
local savedPositionCFrame = nil -- Changed name to reflect it stores a CFrame
local emergencyTeleportActiveConnection = nil -- To manage the health changed connection

-- Save Position Button
TabSetting:AddButton({"Save Position", function()
    local playerRoot = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if playerRoot then
        savedPositionCFrame = playerRoot.CFrame
        print("Position Saved:", savedPositionCFrame)
    else
        warn("Your character is not ready to save position.")
    end
})

-- Teleport to Saved Position Button
TabSetting:AddButton({"Teleport to Saved Position", function()
    local playerRoot = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if playerRoot and savedPositionCFrame then
        playerRoot.CFrame = savedPositionCFrame
        print("Teleported to Saved Position")
    else
        warn("No saved position or your character is not ready.")
    end
})

TabSetting:AddParagraph({"READ THIS!", "This is for your safety.\nIf a player attempts to kill you and your health drops to 70 or below, you will automatically teleport to the preset coordinates to stay safe.\n\nThis works only if a player tries to kill you, don't try this on fire or poison (it relies on combat damage)."})

-- Variables for "Safety First" feature
local emergencyTeleportPosition = CFrame.new(144, 419, 46) -- Changed to CFrame for consistency
local safetyToggled = false -- Renamed `toggled` to avoid conflict
local emergencyPlatform = nil -- Renamed `platform` for clarity

-- Function to set up character health monitoring for Safety First
local function setupSafetyCharacterMonitoring()
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    local rootPart = character:WaitForChild("HumanoidRootPart")

    -- Disconnect previous connection if it exists
    if emergencyTeleportActiveConnection then
        emergencyTeleportActiveConnection:Disconnect()
    end

    emergencyTeleportActiveConnection = humanoid.HealthChanged:Connect(function(health)
        if safetyToggled then
            if health <= 70 then
                -- Only save position IF we are about to teleport to safety and haven't saved already
                if not savedPositionCFrame then
                    savedPositionCFrame = rootPart.CFrame -- Save current CFrame before emergency teleport
                    print("Emergency: Original position saved.")
                end
                
                -- Teleport to safety
                rootPart.CFrame = emergencyTeleportPosition
                rootPart.Velocity = Vector3.new(0, 0, 0) -- Prevent falling
                rootPart.AssemblyLinearVelocity = Vector3.new(0,0,0) -- Also reset assembly velocity
                
                -- Create an invisible platform if not already created
                if not emergencyPlatform then
                    emergencyPlatform = Instance.new("Part")
                    emergencyPlatform.Name = "SafetyPlatform"
                    emergencyPlatform.Size = Vector3.new(10, 1, 10)
                    emergencyPlatform.CFrame = emergencyTeleportPosition * CFrame.new(0, -5, 0) -- Adjust position relative to teleport
                    emergencyPlatform.Anchored = true
                    emergencyPlatform.CanCollide = true
                    emergencyPlatform.Transparency = 1
                    emergencyPlatform.Parent = Workspace
                    print("Emergency: Teleported to safety position and created platform.")
                end
            elseif health > 70 and savedPositionCFrame then -- Return to original spot if health recovers and a position was saved
                -- This 'recover' health condition might need adjustment based on game mechanics
                -- For example, if you only want to return when health is full, use health == humanoid.MaxHealth
                if emergencyPlatform then
                    emergencyPlatform:Destroy()
                    emergencyPlatform = nil
                    print("Emergency: Destroyed safety platform.")
                end
                rootPart.CFrame = savedPositionCFrame
                rootPart.Velocity = Vector3.new(0, 0, 0) -- Reset velocity
                rootPart.AssemblyLinearVelocity = Vector3.new(0,0,0)
                savedPositionCFrame = nil -- Clear saved position after returning
                print("Emergency: Returned to original position.")
            end
        end
    end)
    print("Safety First: Character health monitoring started.")
end

-- Connect `setupSafetyCharacterMonitoring` when character is added (for respawns)
player.CharacterAdded:Connect(setupSafetyCharacterMonitoring)
-- Also call it immediately if character already exists
if player.Character then
    setupSafetyCharacterMonitoring()
end

TabSetting:AddToggle({
    Name = "Safety First",
    Default = false,
    Callback = function(v)
        safetyToggled = v
        if not v then -- If toggle is turned OFF
            print("Safety First: Toggle OFF. Cleaning up.")
            -- Disconnect the health changed event
            if emergencyTeleportActiveConnection then
                emergencyTeleportActiveConnection:Disconnect()
                emergencyTeleportActiveConnection = nil
            end
            -- Destroy platform if it exists
            if emergencyPlatform then
                emergencyPlatform:Destroy()
                emergencyPlatform = nil
            end
            -- If you want to return to saved position immediately when toggle is OFF
            -- this logic might need adjustment based on how `savedPositionCFrame` is used
            -- and if the player is currently at the emergency spot.
            -- For now, it will only return if health recovers, or player manually teleports back.
            -- If you want to force return when toggle is OFF, regardless of health:
            -- if savedPositionCFrame and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            --    player.Character.HumanoidRootPart.CFrame = savedPositionCFrame
            --    savedPositionCFrame = nil
            -- end
        else
            print("Safety First: Toggle ON. Monitoring player health.")
            -- Re-establish monitoring if it's off (handled by setupSafetyCharacterMonitoring)
            setupSafetyCharacterMonitoring()
        end
    end
})
